"""Property-based tests for debate engine.

Feature: cold-case-crawler
Properties 4, 5: Debate Engine Correctness
Validates: Requirements 2.4, 2.5
"""

from uuid import uuid4

from hypothesis import given, settings, strategies as st

from src.models.case import CaseFile
from src.models.script import DialogueLine, PodcastScript


# Strategies for generating valid DialogueLines
valid_speakers = st.sampled_from(["dr_aris_thorne", "maya_vance"])
valid_emotion_tags = st.sampled_from([
    "scoffs", "clears_throat", "dramatic_pause", "sighs",
    "excited", "whispers", "interrupting", "gasps", "neutral"
])
non_empty_text = st.text(min_size=1, max_size=200).filter(lambda x: x.strip())


def dialogue_line_strategy() -> st.SearchStrategy[DialogueLine]:
    """Strategy for generating valid DialogueLine objects."""
    return st.builds(
        DialogueLine,
        speaker=valid_speakers,
        text=non_empty_text,
        emotion_tag=valid_emotion_tags,
    )


def alternating_dialogue_strategy(min_size: int = 2, max_size: int = 20) -> st.SearchStrategy[list[DialogueLine]]:
    """Strategy for generating alternating dialogue lines (maya, thorne, maya, thorne, ...).
    
    This generates dialogue that properly alternates between speakers,
    starting with maya_vance.
    """
    @st.composite
    def build_alternating(draw: st.DrawFn) -> list[DialogueLine]:
        size = draw(st.integers(min_value=min_size, max_value=max_size))
        # Ensure even number for proper alternation
        if size % 2 != 0:
            size += 1
        
        lines: list[DialogueLine] = []
        for i in range(size):
            speaker = "maya_vance" if i % 2 == 0 else "dr_aris_thorne"
            text = draw(non_empty_text)
            emotion_tag = draw(valid_emotion_tags)
            lines.append(DialogueLine(speaker=speaker, text=text, emotion_tag=emotion_tag))
        
        return lines
    
    return build_alternating()


def case_file_strategy() -> st.SearchStrategy[CaseFile]:
    """Strategy for generating valid CaseFile objects."""
    return st.builds(
        CaseFile,
        case_id=st.text(min_size=1, max_size=50).filter(lambda x: x.strip()).map(lambda x: f"case-{x}"),
        title=st.text(min_size=1, max_size=100).filter(lambda x: x.strip()),
        location=st.text(min_size=1, max_size=50).filter(lambda x: x.strip()),
        raw_content=st.text(min_size=1, max_size=500).filter(lambda x: x.strip()),
        evidence_list=st.just([]),
        source_urls=st.just([]),
    )


def compile_script(case: CaseFile, dialogue_lines: list[DialogueLine]) -> PodcastScript:
    """
    Standalone compile_script function for testing.
    
    This mirrors the DebateEngine.compile_script method but doesn't require
    instantiating the full engine with API keys.
    """
    script_id = f"script-{uuid4().hex[:12]}"
    episode_title = f"The {case.location} Mystery: {case.title}"
    
    # Generate social hooks
    hooks: list[str] = []
    hook_indicators = [
        "wait", "but here's the thing", "the evidence", "nobody knew",
        "the truth", "what if", "think about it", "full body chills",
        "the timeline", "the alibi",
    ]
    
    for line in dialogue_lines:
        text_lower = line.text.lower()
        if any(indicator in text_lower for indicator in hook_indicators):
            hook = line.text.strip()
            if 20 < len(hook) < 280:
                hooks.append(hook)
    
    return PodcastScript(
        script_id=script_id,
        case_id=case.case_id,
        episode_title=episode_title,
        chapters=dialogue_lines,
        social_hooks=hooks[:5],
    )


class TestProperty4DebateSpeakerAlternation:
    """Property 4: Debate Speaker Alternation.
    
    *For any* PodcastScript generated by the Debate_Engine, the speakers in 
    consecutive DialogueLines SHALL alternate between 'dr_aris_thorne' and 
    'maya_vance' (no two consecutive lines from the same speaker).
    
    **Validates: Requirements 2.4**
    """

    @settings(max_examples=100)
    @given(dialogue_lines=alternating_dialogue_strategy(min_size=2, max_size=20))
    def test_compiled_script_maintains_alternation(
        self, dialogue_lines: list[DialogueLine]
    ) -> None:
        """compile_script preserves speaker alternation from input."""
        # Create a minimal case for compilation
        case = CaseFile(
            case_id="test-case-001",
            title="Test Case",
            location="Test Location",
            raw_content="Test content for the case.",
        )
        
        script = compile_script(case, dialogue_lines)
        
        # Verify alternation is preserved
        for i in range(1, len(script.chapters)):
            prev_speaker = script.chapters[i - 1].speaker
            curr_speaker = script.chapters[i].speaker
            assert prev_speaker != curr_speaker, (
                f"Consecutive speakers at positions {i-1} and {i} are the same: {prev_speaker}"
            )

    @settings(max_examples=100)
    @given(dialogue_lines=alternating_dialogue_strategy(min_size=2, max_size=20))
    def test_alternation_starts_with_maya(
        self, dialogue_lines: list[DialogueLine]
    ) -> None:
        """Debate should start with Maya Vance."""
        case = CaseFile(
            case_id="test-case-001",
            title="Test Case",
            location="Test Location",
            raw_content="Test content for the case.",
        )
        
        script = compile_script(case, dialogue_lines)
        
        # First speaker should be Maya
        assert script.chapters[0].speaker == "maya_vance", (
            f"First speaker should be maya_vance, got {script.chapters[0].speaker}"
        )


class TestProperty5DialogueLineCompilationCompleteness:
    """Property 5: DialogueLine Compilation Completeness.
    
    *For any* list of DialogueLines passed to the Debate_Engine's compilation step, 
    the resulting PodcastScript SHALL contain all DialogueLines in the chapters field, 
    preserving their order.
    
    **Validates: Requirements 2.5**
    """

    @settings(max_examples=100)
    @given(dialogue_lines=st.lists(dialogue_line_strategy(), min_size=1, max_size=30))
    def test_all_dialogue_lines_preserved(
        self, dialogue_lines: list[DialogueLine]
    ) -> None:
        """compile_script preserves all input DialogueLines."""
        case = CaseFile(
            case_id="test-case-001",
            title="Test Case",
            location="Test Location",
            raw_content="Test content for the case.",
        )
        
        script = compile_script(case, dialogue_lines)
        
        # Verify count matches
        assert len(script.chapters) == len(dialogue_lines), (
            f"Expected {len(dialogue_lines)} chapters, got {len(script.chapters)}"
        )

    @settings(max_examples=100)
    @given(dialogue_lines=st.lists(dialogue_line_strategy(), min_size=1, max_size=30))
    def test_dialogue_order_preserved(
        self, dialogue_lines: list[DialogueLine]
    ) -> None:
        """compile_script preserves the order of DialogueLines."""
        case = CaseFile(
            case_id="test-case-001",
            title="Test Case",
            location="Test Location",
            raw_content="Test content for the case.",
        )
        
        script = compile_script(case, dialogue_lines)
        
        # Verify order is preserved
        for i, (original, compiled) in enumerate(zip(dialogue_lines, script.chapters)):
            assert original.speaker == compiled.speaker, (
                f"Speaker mismatch at position {i}: expected {original.speaker}, got {compiled.speaker}"
            )
            assert original.text == compiled.text, (
                f"Text mismatch at position {i}"
            )
            assert original.emotion_tag == compiled.emotion_tag, (
                f"Emotion tag mismatch at position {i}: expected {original.emotion_tag}, got {compiled.emotion_tag}"
            )

    @settings(max_examples=100)
    @given(dialogue_lines=st.lists(dialogue_line_strategy(), min_size=1, max_size=30))
    def test_script_metadata_populated(
        self, dialogue_lines: list[DialogueLine]
    ) -> None:
        """compile_script populates script metadata correctly."""
        case = CaseFile(
            case_id="test-case-001",
            title="Test Case",
            location="Test Location",
            raw_content="Test content for the case.",
        )
        
        script = compile_script(case, dialogue_lines)
        
        # Verify metadata
        assert script.script_id.startswith("script-"), (
            f"script_id should start with 'script-', got {script.script_id}"
        )
        assert script.case_id == case.case_id, (
            f"case_id mismatch: expected {case.case_id}, got {script.case_id}"
        )
        assert case.location in script.episode_title, (
            f"episode_title should contain location '{case.location}'"
        )
        assert case.title in script.episode_title, (
            f"episode_title should contain case title '{case.title}'"
        )
